# `const <type> *` vs `const <type>[]`

## `const <type> *`

- **ポインタ宣言**
  - ポインタ先の各要素は`const`のため変更不可。
- **メモリアドレス**
  - 指定された型のアドレスを保持し、所有権やメモリ管理の詳細を示すものではない。
- **ユースケース**
  - 通常、動的メモリの確保や静的ストレージ、または既存のポインタ先の要素を変更することなく指すために使われる。
- **ポインタの変更**
  - ポインタ先そのものを変更することができるが、ポインタを通してポインタ先の各値を変更することはできない。

    ```c++
    const float * ptr = new const float[3]{1.0f, 2.0f, 3.0f};
    // ptr[0] = 1.5f; // Error: Cannot modify const float
    ptr = nullptr; // OK: Changing the pointer itself is allowed
    // ptr = new const float[4]{1.0f, 2.0f, 3.0f, 4.0f};
    ```

## `const <type> []`

- **配列宣言**
  - 静的を配列宣言する。配列サイズを明示的に指定するか、コンパイル時にイニシャライザによって推定される。
- **固定メモリ**
  - 配列のサイズとポインタ位置は静的。(グローバルや静的に宣言されない限り)多くの場合スタック上にあり、要素を一度初期化されると変更不可。
- **ライフタイムとスコープ**
  - ライフタイムは配列のスコープにひも付き、ローカル(スタック上)で宣言されている場合、配列とその要素は自動的に管理される。
- **初期化要件**
  - 要素は宣言時に初期化される必要があり、再割当てやリサイズは不可。

    ```c++
    const float arr[] = {1.0f, 2.0f, 3.0f};
    // arr[0] = 1.5f; // Error: Cannot modify const float
    // arr = {4.0f, 5.0f, 6.0f}; // Error: Arrays cannot be reassigned
    ```

## 類似点と使用上の考慮事項

- **ポインタの柔軟性 vs 配列の安全性**
  - `const float *`は異なる配列やポインタにリダイレクトできるため柔軟性が高い。一方、`const float []`明確に定義されたサイズとスコープによって、配列への意図しない書き込みを防ぐ。
- **メモリ管理**
  - `const float *`を使う場合、動的にメモリを割り当てる特に、メモリ管理に気をつける必要がある。一方`const float []`はメモリ管理をスコープ内で行い、通常明示的な破棄は必要ない。
- **パフォーマンス**
  - `const float []`は小さくよくアクセスされる配列の場合、参照の局所性からパフォーマンス上の利点をもたらす可能性がある。